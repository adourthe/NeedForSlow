<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Reconnaissance de gamePad</title>
        <meta name="viewport" content="width=device-width">
        <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script>
 
    </head>
    <body>
	<canvas id="gameScene" width="1000" height="600" style="border:1px solid; border-radius:2px;"  ></canvas>
	<div id="generalPrompt"></div>    
	<div id="gamepadPrompt"></div>
    <div id="gamepadDisplay"></div>
 	
	
    <script>
    var serverAdress = "ws://localhost"
    var serverPort = "1099"
    var hasGP = false; //est ce que le gamePad est connecté?
    var repGP;
    var hasKeyboard = false;

    var connection;
 
	//Le navigateur reconnait il cette propriété?
    function canGame() {
        return "getGamepads" in navigator;
    }
 
	
    function reportOnGamepad() {
        var gp = navigator.getGamepads()[0];//on peut connecter plus d'un gamepad mais on ne teste que le premier ici.
        var html = "";
        html += "id: "+gp.id+"<br/>"; //l'objet gamePad a un identifiant de vendeur
 
        for(var i=0;i<gp.buttons.length;i++) { //Il a aussi une collection de boutons (un tableau)
            html+= "Button "+(i+1)+": ";
            if(gp.buttons[i].pressed) html+= " pressed"; //chaque bouton a un état
            html+= "<br/>";
        }
 
        for(var i=0;i<gp.axes.length; i+=2) {//gestion de l'information du joystic (ou du pavé gauche: seulement 2 axes pour Vertical ou horizontal)
            html+= "Stick "+(Math.ceil(i/2)+1)+": "+gp.axes[i]+","+gp.axes[i+1]+"<br/>";  //conversion en (x,y)
        }
 
        $("#gamepadDisplay").html(html); //Affichage
    }// voyez que cette fonction n'est pas rattachée à un événement: elle sera appelée régulièrement par un setInterval (cf plus bas).
 
 
	//fonction principale lancée au chargement complet de la page 
    $(document).ready(function() {
 
        if(canGame()) { //on vérifie si le navigateur est suffisament récent.
 
            var prompt = "Pour commencer, branchez votre gamePad et appuyez sur un bouton";
            $("#gamepadPrompt").text(prompt);
 
            $(window).on("gamepadconnected", function() { //rattachement  de l'événement (cf plus bas) à une callback
                hasGP = true; //on garde en mémoire qu'il existe un gamePad
                $("#gamepadPrompt").html("Gamepad connected!");
                console.log("connection event");

                // if user is running mozilla then use it's built-in WebSocket
			    window.WebSocket = window.WebSocket || window.MozWebSocket;

			    // if browser doesn't support WebSocket, just show some notification and exit
			    if (!window.WebSocket) {
			    	$("generalPrompt").text('Sorry, but your browser doesn\'t '
                                    + 'support WebSockets.');
			        return;
			    }

			    // open connection
			    connection = new WebSocket(serverAdress + ":" + serverPort);
                
			    connection.onopen = function () {
			        $("generalPrompt").text("Pour commencer, branchez votre gamePad et appuyez sur un bouton");
			    };

			    connection.onerror = function (error) {
			        $("generalPrompt").text("Sorry, but there\'s some problem with your "
                                    + "connection or the server is down.");
			    };

			    // most important part - incoming messages
			    connection.onmessage = function (message) {
			        // try to parse JSON message. Because we know that the server always returns
			        // JSON this should work without any problem but we should make sure that
			        // the massage is not chunked or otherwise damaged.
			        try {
			            var json = JSON.parse(message.data);
			        } catch (e) {
			            console.log('This doesn\'t look like a valid JSON: ', message.data);
			            return;
			        }

			        posX = json.posX;
			     	posY = json.posY;
			        angle = json.angle;

			        drawScene();   
			    }

                //Ceci est une boucle de jeu
                repGP = window.setInterval(reportOnGamepad,100); //On interroge régulièrement le gamePad pour connaître ses variations d'état
                //Dans l'idéal, on utilise pas setInterval mais requestAnimationFrame (cf http://creativejs.com/resources/requestanimationframe/)

				setInterval(gameLoop, 15); 
            });
 
            $(window).on("gamepaddisconnected", function() {//récupération de l'événement (cf plus bas)
                console.log("disconnection event");
                $("#gamepadPrompt").text(prompt);
                window.clearInterval(repGP);
            });

            $(window).on("keyboardconnected", function() {//récupération de l'événement (cf plus bas)
                hasKeyboard = true; //on garde en mémoire qu'il existe un gamePad
                $("#gamepadPrompt").html("Keyboard connected!");
                console.log("connection event");

                // if user is running mozilla then use it's built-in WebSocket
			    window.WebSocket = window.WebSocket || window.MozWebSocket;

			    // if browser doesn't support WebSocket, just show some notification and exit
			    if (!window.WebSocket) {
			    	$("generalPrompt").text('Sorry, but your browser doesn\'t '
                                    + 'support WebSockets.');
			        return;
			    }

			    // open connection
			    connection = new WebSocket(serverAdress + ":" + serverPort);
                
			    connection.onopen = function () {
			        $("generalPrompt").text("Pour commencer, branchez votre gamePad et appuyez sur un bouton");
			    };

			    connection.onerror = function (error) {
			        $("generalPrompt").text("Sorry, but there\'s some problem with your "
                                    + "connection or the server is down.");
			    };

			    // most important part - incoming messages
			    connection.onmessage = function (message) {
			        // try to parse JSON message. Because we know that the server always returns
			        // JSON this should work without any problem but we should make sure that
			        // the massage is not chunked or otherwise damaged.
			        try {
			            var json = JSON.parse(message.data);
			        } catch (e) {
			            console.log('This doesn\'t look like a valid JSON: ', message.data);
			            return;
			        }

			        posX = json.posX;
			     	posY = json.posY;
			        angle = json.angle;

			        drawScene();   
			    }

                //Ceci est une boucle de jeu
                //repGP = window.setInterval(reportOnGamepad,100); //On interroge régulièrement le gamePad pour connaître ses variations d'état
                //Dans l'idéal, on utilise pas setInterval mais requestAnimationFrame (cf http://creativejs.com/resources/requestanimationframe/)

				setInterval(gameLoop, 15); 
            });
 
            //Chrome nécessite un petit interval, Firefox, non, mais cela ne dérange pas.
            var checkGP = window.setInterval(function() {
                console.log('checkGP');
                if(navigator.getGamepads()[0]) {
                    if(!hasGP && !hasKeyboard) $(window).trigger("gamepadconnected"); //déclenchement de l'événement
                    window.clearInterval(checkGP);
                }
            }, 500);

            $window.on("keydown", function(e){
        		var event = window.event ? window.event : e;
            	if(!hasGP && !hasKeyboard){
            		if(event.keyCode >= 37 && event.keyCode <= 40){
            			$(window).trigger("keyboardconnected"); //déclenchement de l'événement	
            		}
            	} else if(hasKeyboard){
            		switch(event.keyCode){
            			case 37:
            				dirTemp = -1;
            				break;
            			case 38:
        					upTemp = true;
            				break;
            			case 39:
            				dirTemp = 1;
            				break;
            			case 40:
            				downTemp = true;
            				break;
            			default:
            				break;
            		}
            	}
                window.clearInterval(checkGP);
            })

            $window.on("keyup", function(e){
        		var event = window.event ? window.event : e;
            	if(hasKeyboard){
            		switch(event.keyCode){
            			case 37:
            				dirTemp = 0;
            				break;
            			case 38:
        					upTemp = false;
            				break;
            			case 39:
            				dirTemp = 0;
            				break;
            			case 40:
            				downTemp = false;
            				break;
            			default:
            				break;
            		}
            	}
                window.clearInterval(checkGP);
            })
        }
    });


	var canvas = document.getElementById('gameScene');
	var ctx = canvas.getContext("2d");

	var angleInDegrees = 0;
	var posX = canvas.width/2, posY = canvas.height/2;
	var carWidth = 52, carHeight = 94;

	var speed = 0;

	var image = document.createElement("img");
	image.onload = function(){
		angle = 0;
		drawCar(posX, posY, carWidth, carHeight, angleInDegrees);
		
	};

	image.src = "car.png";

	var upTemp = false;
	var downTemp = false;
	var dirTemp = 0;

	function drawCar(posX, posY, larg, haut, angle){
		ctx.clearRect(0,0,canvas.width,canvas.height);
		ctx.save();
		ctx.translate(posX,posY);
		ctx.rotate(angle);
		ctx.drawImage(image,0,0,image.width,image.height, -larg/2, -haut/2,larg,haut);
		ctx.restore();
	}

	function gameLoop(){
		//updateState();
		sendState();
		//drawScene();
	}

	function sendState(){
		var gp = navigator.getGamepads()[0];
		var state;

		if(hasGP){
			state = {
				up : gp.buttons[7].pressed,
				down : gp.buttons[6].pressed,
				dir : gp.axes[0]
			}
		} else if(hasKeyboard){

			state = {
				up : upTemp,
				down : downTemp,
				dir : dirTemp
			}
		}

		connection.send(JSON.stringify(state));
	}

	function updateState(){
		var gp = navigator.getGamepads()[0];
		
		if (gp.axes[0] < -0.4 && speed != 0) {
			angle += -0.05;		
		} else if (gp.axes[0] > 0.4 && speed != 0) {
			angle += 0.05;		
		}

		if (gp.buttons[7].pressed) {			
			speed = Math.min(speed + 0.1, 7);
		} else if (gp.buttons[6].pressed) {
			speed = Math.max(speed - 0.1, -5);
		} else {
			if(speed > 0){
				speed = Math.max(speed - 0.05, 0);
			} else {
				speed = Math.min(speed + 0.05, 0);
			}
		}

		if(posX - carHeight/2 < 0){
			speed = 0;
			posX = carHeight/2;
		}

		if(posX + carHeight/2 > canvas.width){
			speed = 0;
			posX = canvas.width - carHeight/2;
		}

		if(posY - carHeight/2 < 0){
			speed = 0;
			posY = carHeight/2;
		}

		if(posY + carHeight/2 > canvas.height){
			speed = 0;
			posY = canvas.height - carHeight/2;
		}

		posX += speed * Math.sin(angle);
		posY -= speed * Math.cos(angle);
	}

	function drawScene(){
		drawCar(posX, posY, carWidth, carHeight, angle);
		//document.getElementById("speedPrompt").innerHTML="Speed : " + speed;
	}
    </script>
    </body>
</html>
